## SP1 Analysis for RISC-V Arch Test Integration

### Current Findings:

**SP1 Structure:**
- Main crates: CLI, SDK, core (executor/machine), zkvm, prover, verifier
- Primary executor: `sp1-perf-executor` binary in `crates/perf/src/executor.rs`
- Main SDK CLI: `cargo prove` binary

**Key Executables:**
1. `sp1-perf-executor` - Performance testing executor with modes:
   - Simple: Basic execution without traces
   - Checkpoint: Execution with checkpointing 
   - Trace: Full execution with event tracing
2. `cargo prove` - Main CLI tool for building/proving programs

**SP1 vs RISC0 Differences (Initial):**
- SP1 uses `sp1-perf-executor` vs RISC0's `r0vm`
- SP1 appears to support multiple execution modes
- Both use RISC-V 32-bit instruction set
- SP1 has more sophisticated toolchain management

**SP1 Executor Interface:**
- Requires `--program <PROGRAM>` (compiled binary)
- Requires `--stdin <STDIN>` (input data) 
- Requires `--executor-mode <MODE>` (simple|checkpoint|trace|shape-collection)
- No obvious `--signatures` or `--test-elf` equivalent found yet

**RISC0 vs SP1 Interface Comparison:**
- RISC0: `r0vm --test-elf my.elf --signatures my.signatures`
- SP1: `sp1-perf-executor --program <file> --stdin <file> --executor-mode trace`

**SP1 I/O Model:**
- Uses syscalls for I/O: WRITE, HALT, etc.
- WRITE syscall uses file descriptors:
  - fd=1: stdout
  - fd=2: stderr  
  - fd=3: public values stream
  - fd=4: hint/input stream
- HALT syscall for program termination with exit codes
- No built-in signature generation - likely need custom implementation

**üîë KEY INSIGHT - Program Format Issue:**
- RISC0 has two execution paths:
  1. Normal: Serialized binary image format (`ExecutorImpl::new()`)
  2. Test ELF: Raw ELF files (`ExecutorImpl::from_kernel_elf()`)
- SP1's `sp1-perf-executor` expects processed/serialized format, not raw ELF
- Architecture test files are raw ELF, causing UnexpectedEof error
- Need to find SP1 equivalent to `from_kernel_elf` or convert ELF to SP1 format

**‚úÖ MEMORY LAYOUT ISSUE - SOLVED:**
- SP1 rejects RISC0-compiled ELF: "address [0x80000000] must be less than [0x78000001]"
- SP1 has different memory layout constraints than RISC0
- RISC0 link.ld places code at 0x80000000, but SP1 max address is ~0x78000000
- Fixed by creating SP1 linker script with base address 0x20000000

**üîç NEW ISSUE - Instruction Disassembly:**
- SP1 successfully loads ELF with correct memory layout
- New error: `process_instruction().unwrap()` fails in `rrs.rs:373`
- Some instruction in arch test ELF is not recognized by SP1's disassembler
- Need to identify which instruction(s) are unsupported

**üéØ ROOT CAUSE IDENTIFIED - Program Termination Issue:**
- Panic occurs at instruction 3277/3282 in SP1's transpile function
- Program ends properly with `ecall` at address 2000332c, but SP1 continues execution
- SP1 tries to execute data sections containing 0xdeadbeef signature padding
- 0xdeadbeef (bits[6:0]=0x6F) decodes as JAL instruction but it's just data
- SP1 lacks proper program termination handling after ecall (unlike RISC0)
- Need SP1 equivalent of RISC0's ELF execution model with signature collection

### Next Steps:
1. ‚úÖ Build SP1 to get executables
2. ‚úÖ Find signature construction capabilities - uses syscalls, no built-in signature support
3. ‚úÖ Test basic program execution with SP1 - identified program format issue
4. ‚úÖ Find SP1's equivalent to RISC0's `from_kernel_elf` method - uses Program::from()
5. ‚úÖ Resolve SP1 memory layout constraints - created SP1-compatible linker script
6. ‚úÖ Identify unsupported instructions in SP1's disassembler and handle them - root cause found
7. üîç Implement proper program termination handling in SP1 for ELF execution
8. üîç Add signature collection support similar to RISC0's approach
9. üîç Complete SP1 workflow for RISC-V arch tests

cargo install --path crates/cli --bin cargo-prove
cargo prove install-toolchain
throw when instructions.len = 3276/3282